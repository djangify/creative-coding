---
// src/components/GenArtPiece.astro
const { id, title, gridClass } = Astro.props;
---

<figure class={`art-piece ${gridClass}`}>
  <div class="art-container">
    <canvas id={`canvas-${id}`} class="size-full"></canvas>

    <div class="art-overlay">
      <h3 class="art-title">{title}</h3>
      <a href={`/art/${id}`} class="view-full">View Full</a>
    </div>
  </div>
</figure>

<script define:vars={{ id }}>
  // Load the art script for this piece
  const canvas = document.getElementById(`canvas-${id}`);
  const ctx = canvas.getContext("2d");

  // Set canvas size
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }

  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  // Load the specific art script based on ID
  async function loadArtScript() {
    try {
      // Import the script content for this piece
      const scriptPath = `/src/assets/art/${id}/script.js`;

      switch (id) {
        case "piece1":
          initAnimatedDots();
          break;
        case "piece2":
          initGeometricWaves();
          break;
        case "animals":
          initAnimals();
          break;
        case "circles":
          initCircles();
          break;
      }
    } catch (error) {
      console.error(`Failed to load art script for ${id}:`, error);
    }
  }

  // piece1 animated dots
  function initAnimatedDots() {
    // Simple random utility functions
    const random = {
      range: (min, max) => Math.random() * (max - min) + min,
      rangeFloor: (min, max) =>
        Math.floor(Math.random() * (max - min + 1)) + min,
    };

    // Vector class
    class Vector {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    // Agent class
    class Agent {
      constructor(x, y) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(
          random.rangeFloor(-1, 1) * 3,
          random.range(-1, 1),
        );
        this.radius = random.range(8, 20);
      }

      bounce(width, height) {
        if (this.pos.x <= this.radius) {
          this.pos.x = this.radius;
          this.vel.x *= -1;
        }
        if (this.pos.x >= width - this.radius) {
          this.pos.x = width - this.radius;
          this.vel.x *= -1;
        }
        if (this.pos.y <= this.radius) {
          this.pos.y = this.radius;
          this.vel.y *= -1;
        }
        if (this.pos.y >= height - this.radius) {
          this.pos.y = height - this.radius;
          this.vel.y *= -1;
        }
      }

      update() {
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
      }

      draw(context) {
        context.save();
        context.translate(this.pos.x, this.pos.y);
        context.lineWidth = 4;
        context.fillStyle = "silver";
        context.strokeStyle = "silver";
        context.beginPath();
        context.arc(0, 0, this.radius, 0, Math.PI * 2);
        context.fill();
        context.stroke();
        context.restore();
      }
    }

    const agents = [];
    const numAgents = Math.min(
      140,
      Math.floor((canvas.width * canvas.height) / 10000),
    );

    // Initialize agents
    for (let i = 0; i < numAgents; i++) {
      const x = random.range(0, canvas.width);
      const y = random.range(0, canvas.height);
      agents.push(new Agent(x, y));
    }

    function animate() {
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      agents.forEach((agent) => {
        agent.update();
        agent.draw(ctx);
        agent.bounce(canvas.width, canvas.height);
      });

      requestAnimationFrame(animate);
    }

    animate();
  }

  function initGeometricWaves() {
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const time = Date.now() * 0.002;
      ctx.strokeStyle = "#4f46e5";
      ctx.lineWidth = 2;

      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 5) {
          const y =
            canvas.height / 2 + Math.sin(x * 0.01 + time + i * 0.5) * 50;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      requestAnimationFrame(animate);
    }
    animate();
  }

  function initAnimals() {
    let animals = [];
    const numAnimals = 30;
    let score = 0;
    let animalTypes = ["bunny", "kitten", "puppy", "fox", "bear", "panda"];
    let lastTouchPosition = { x: 0, y: 0 };

    // Create animals
    function createAnimals(count) {
      for (let i = 0; i < count; i++) {
        let x = Math.random() * (canvas.width - 200) + 100;
        let y = Math.random() * (canvas.height - 200) + 100;
        let type = animalTypes[Math.floor(Math.random() * animalTypes.length)];

        animals.push(new Animal(x, y, 50, type));
      }
    }

    class Animal {
      constructor(x, y, size, type) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.type = type;

        this.emoji = "ðŸ°";
        if (type === "bunny") this.emoji = "ðŸ°";
        if (type === "kitten") this.emoji = "ðŸ±";
        if (type === "puppy") this.emoji = "ðŸ¶";
        if (type === "fox") this.emoji = "ðŸ¦Š";
        if (type === "bear") this.emoji = "ðŸ»";
        if (type === "panda") this.emoji = "ðŸ¼";
      }

      display() {
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.emoji, this.x, this.y);
      }
    }

    // Animation loop
    function animate() {
      // Clear canvas with semi-transparent background
      ctx.fillStyle = "rgba(240, 240, 250, 0.3)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw score
      ctx.fillStyle = "#333";
      ctx.font = "20px Arial";
      ctx.textAlign = "right";
      ctx.fillText(score, canvas.width - 40, 60);

      // Update and draw animals
      for (let i = animals.length - 1; i >= 0; i--) {
        animals[i].display();
      }

      // Add more animals if needed
      if (animals.length < 15) {
        createAnimals(5);
      }

      requestAnimationFrame(animate);
    }

    // Handle clicks/touches
    function handleInteraction(x, y) {
      for (let i = animals.length - 1; i >= 0; i--) {
        let animal = animals[i];
        let distance = Math.sqrt((x - animal.x) ** 2 + (y - animal.y) ** 2);

        if (distance < animal.size / 1) {
          // Draw effect
          ctx.fillStyle = "rgba(255, 200, 200, 0.8)";
          ctx.beginPath();
          ctx.arc(animal.x, animal.y, animal.size, 0, Math.PI * 2);
          ctx.fill();

          // Remove animal and increase score
          animals.splice(i, 1);
          score++;

          // Add new animal
          if (animals.length < 10) {
            createAnimals(1);
          }
          break;
        }
      }
    }

    // Event listeners
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      handleInteraction(e.clientX - rect.left, e.clientY - rect.top);
    });

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      handleInteraction(touch.clientX - rect.left, touch.clientY - rect.top);
    });

    // Initialize
    createAnimals(numAnimals);
    animate();
  }

  function initCircles() {
    let circles = [];
    const numCircles = 80;
    let specialCircle;
    let centerX, centerY;

    // Define classes first
    class Circle {
      constructor(x, y, size, color) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = size;
        this.color = color;
        this.speed = Math.random() * 0.05 + 0.03;
        this.maxForce = Math.random() * 7 + 5;
        this.friction = 0.95;
      }

      attractToSpecial(specialCircle) {
        let dx = specialCircle.x - this.x;
        let dy = specialCircle.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > specialCircle.size / 2 + this.size / 2) {
          let strength = 0.01;
          this.vx += dx * strength;
          this.vy += dy * strength;
        }
      }

      update(mouseX, mouseY, mousePressed) {
        // Apply mouse repulsion
        let d = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
        let repulsionRadius = 100 + this.size;

        if (d < repulsionRadius) {
          let angle = Math.atan2(this.y - mouseY, this.x - mouseX);
          let force = Math.max(
            0,
            Math.min(this.maxForce, this.maxForce * (1 - d / repulsionRadius)),
          );
          this.vx += Math.cos(angle) * force;
          this.vy += Math.sin(angle) * force;
        }

        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Keep within bounds
        if (this.x < this.size / 2) {
          this.x = this.size / 2;
          this.vx *= -0.8;
        } else if (this.x > canvas.width - this.size / 2) {
          this.x = canvas.width - this.size / 2;
          this.vx *= -0.8;
        }

        if (this.y < this.size / 2) {
          this.y = this.size / 2;
          this.vy *= -0.8;
        } else if (this.y > canvas.height - this.size / 2) {
          this.y = canvas.height - this.size / 2;
          this.vy *= -0.8;
        }
      }

      display() {
        // Shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
        ctx.beginPath();
        ctx.arc(this.x + 2, this.y + 2, this.size / 2, 0, Math.PI * 2);
        ctx.fill();

        // Circle
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class SpecialCircle extends Circle {
      constructor(x, y, size, borderColor) {
        super(x, y, size, "rgba(0, 0, 0, 0)");
        this.borderColor = borderColor;
        this.borderWeight = 4;
        this.maxForce = 2;
      }

      update(mouseX, mouseY, mousePressed) {
        if (mousePressed) {
          this.x = mouseX;
          this.y = mouseY;
        } else {
          this.x += (centerX - this.x) * 0.02;
          this.y += (centerY - this.y) * 0.02;
        }
      }

      display() {
        // Draw border with glow
        for (let i = 3; i > 0; i--) {
          ctx.strokeStyle = `rgba(255, 100, 150, ${0.2 / i})`;
          ctx.lineWidth = this.borderWeight + i * 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Main border
        ctx.strokeStyle = this.borderColor;
        ctx.lineWidth = this.borderWeight;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // Now we can use the classes
    // Get canvas dimensions
    centerX = canvas.width / 2;
    centerY = canvas.height / 2;

    // Create special circle at center
    specialCircle = new SpecialCircle(centerX, centerY, 50, "#ff6496");

    // Create regular circles in a bunch around the special circle
    for (let i = 0; i < numCircles; i++) {
      let angle = Math.random() * Math.PI * 2;
      let radius = Math.random() * 150 + 150;
      let x = centerX + Math.cos(angle) * radius;
      let y = centerY + Math.sin(angle) * radius;

      circles.push(
        new Circle(
          x,
          y,
          Math.random() * 20 + 20,
          `rgba(${Math.random() * 155 + 100}, ${Math.random() * 100 + 100}, ${Math.random() * 105 + 150}, 0.7)`,
        ),
      );
    }

    // Track mouse position
    let mouseX = 0,
      mouseY = 0,
      mousePressed = false;

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener("mousedown", () => (mousePressed = true));
    canvas.addEventListener("mouseup", () => (mousePressed = false));

    // Animation loop
    function animate() {
      // Clear with semi-transparent background
      ctx.fillStyle = "rgba(240, 240, 250, 0.3)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update and display special circle
      specialCircle.update(mouseX, mouseY, mousePressed);
      specialCircle.display();

      // Update and display regular circles
      for (let circle of circles) {
        if (!mousePressed) {
          circle.attractToSpecial(specialCircle);
        }
        circle.update(mouseX, mouseY, mousePressed);
        circle.display();
      }

      requestAnimationFrame(animate);
    }

    animate();
  }

  loadArtScript();
</script>

<style>
  .art-piece {
    position: relative;
    overflow: hidden;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease;
  }

  .art-piece:hover {
    transform: scale(1.02);
  }

  .art-container {
    position: relative;
    width: 100%;
    height: 100%;
    min-height: 200px;
  }

  .art-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
    color: white;
    padding: 1rem;
    transform: translateY(100%);
    transition: transform 0.3s ease;
  }

  .art-piece:hover .art-overlay {
    transform: translateY(0);
  }

  .art-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .view-full {
    color: #fbbf24;
    text-decoration: none;
    font-size: 0.9rem;
    transition: color 0.3s ease;
  }

  .view-full:hover {
    color: #f59e0b;
  }

  canvas {
    display: block;
    background: #1f2937;
  }
</style>
